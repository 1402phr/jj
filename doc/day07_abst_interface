#day07

Object 클래스 : 최상위 super 클래스
				자바로 만들어지 모든 클래스는 Object가 제공하는 모든 멤버(변수, 함수)를 
				자동적으로 사용할 수 있다
				
				최상위 클래스를 만든 이유? 
					> 원활한 계층추적을 위한 조치
					> 각 클래스의 족보를 정확하게 따질 수 있다
					> 자바로 만든 모든 클래스는 반드시 상위 클래스를 가지고 있다
					> 만약 강제로 상위 클래스를 지정하지 않으면(extends) 암묵적으로 Object 클래스를 상속받아 만들어진다
		
		instanceof : 특정 클래스를 new 시키면 주소가 만들어지는데 
					 이 주소가 어떤 클래스 소속인지를 알려주는 연산자
					 연사 결과는 T/F로 반환
					 	형식 : 주소 instanceof 클래스이름
								 	> 주소가 가리키는 곳의 내용이 지정한 클래스 소속인지를 물어보는 기능
								 	> 소속이라는 개념은 is a 관계를 따지는 것
								 	

								 	
final 속성
	1. final 클래스 : 상속과 연관됨
					  상속이 불가능한 클래스임을 밝히는 역할
					  기능을 추가 또는 변경하지말고 현재 기능 그대로 사용하라는 의미
	2. final 함수 : 오버라이드와 연관
					오버라이드가 불가능한 함수임을 밝히는 역할
					이 함수는 중요한 함수이므로 기능을 바꾸지 말고 현재 기능을 그대로 사용하라는 의미
	3. final 변수 : 값을 수정할 수 없는 변수
					현재 값을 유지해야함(상수)
					
					
					
package와 import
	package : 자바 프로그램(소스)가 들어있는 폴더를 부르는 용어
			  자바는 오픈 소스 프로그램이라 모든 사람이 자신이 만든 프로그램을 다른 사람에게 배포할 수 있고 
			  그것을 이용할 수 있음 > 이로 인해 클래스이름에서 충돌이 생기는 문제가 발생할 수 있다
	 		  이 문제를 해결하기 위해 만든것이 패키지
	 		  따라서, 자바 프로그램을 만들 때에는 반드시 이 프로그램이 어떤 폴더(패키지)에 저장되는지 알려주도록 해놓았다
	 		  	> 형식 : package 폴더이름;
	 		  	> 패키지 이름 생성의 권장사항
	 		  		1. 자신이 사용하는 도메인을 거꾸로 쓴 후 다시 폴더 이름을 붙이기
	 		  			예 ) 도메인 : banjang.cnu.ac.kr > 패키지 : kr.ac.cnu.banjang.day01;
	 		  			
	import : 자신이 사용할 클래스가 어느 폴더(패키지)에 있는 것인지 밝혀주는 역할
			 	예 ) Test라는 클래스를 만들어서 Sample 폴더에 저장
			 		 Test라는 클래스를 만들어서 day 폴더에 저장
			 		 	> import Sample.Test; 	: Sample 패키지의 Test 클래스
			 		 	  import day.Test;	: day 패키지의 Test 클래스
			 	형식1 ) import 패키지경로.클래스이름;	> 패키지 안의 지정 클래스
			 	형식2 ) import 패키지경로.*; 	> 패키지 바로 하위에 있는 모든 클래스 사용
			 		> 형식1을 우선 적용
			 
			 	예외 ) import 하지 않아도 명시적으로 클래스 이름 앞에 패키지 이름을 붙여서 사용할 수 있다
			 		> 유일하게 java.lang 패키지는 워낙 기본적이고 많이 쓰느 기능이라 임포트없이 바로 사용 가능(JVM이 알아서 찾음) 
			 		> @See day07 - Test04
			 		> 형식 ) 패키지경로.사용할클래스이름 변수이름 = new 패키지경로.사용할클래스이름();
			 					>static 멤버인 경우, new  시킬 필요 없음 
			 	*를 사용해서 임포트하는 경우 )
			 		하위 패키지 소속 클래스는 사용불가
			 			예 ) import java.awt.*;
			 				 import java.awt.event.*;
			 				 	> 인덱스 찾아보면 java.awt랑 java.awt.event 랑 따로있음
			 				 	
			 				 	
static import : static 멤버는 원칙적으로 
				클래스이름.멤버
				의 형식으로 사용해야한다
				
				이때 클래스이름을 생략할 수 있는데 이 방법이 static import 이다
					형식 ) import static 패키지경로.클래스이름.*;
					
					
추상클래스 : 추상함수를 0개 이상 가지고 있는 클래스 
			 	> 추상함수가 있으면 반드시 추상클래스가 되고 없어도 추상클래스가 될 수 있음
			 new 시켜서 사용 불가능한 클래스 = 메모리에 올릴 수 없다 = 실행할 수 없다
			 	> 자식클래스(일반 클래스)에 상속시켜서 자식클래스를 new 시켜서 사용
			 	  추상클래스 변수 = new 자식클래스;
			 	> 보통은 상속시켜서 사용하는 경우는 잘없고 자기 자신을 반환값으로 갖는 static 함수를 사용한다
			 		예 ) api인덱스 - java.util - calendar - static calendar
			 				> static 함수는 먼저 static 영역에 올라가니까 new 안해도 사용 가능
			 	> 또는 재정의해서 사용 = 재정의해서 몸체가 있는 일반함수로 바꿔주는것
			 	  이걸 어노테이션이라 부름
			 	   
			 	
	추상함수 : 함수의 몸체가(실행내용 : {} ) 없는 함수를 말한다
			   즉, 기능이 없는 함수(C언어에서는 가상함수라고 한다)
			   		형식 ) [접근지정자] abstract 반환값타입 함수이름(매개변수리스트);
			   					> 함수의 원형만을 정의해둠(실제 기능은 사용하면서 만들어라)
			   					예 ) public abstract void abc(String name);
			   왜 추상함수를 만드는가? 
			   		> 사용하면서 필요한 기능을 만들라는 것임
			   		> 예 ) actionPerformed에서 대체 무슨 액션을 원할줄 알고 함수를 미리 만들겠어
	추상클래스를 만드는 방법
		형식 ) [접근지정자] abstract class 클래스이름 {
					변수;
					일반함수;
					추상함수;		//없어도 됨
				}	
				
	추상클래스 사용 방법
		: 추상 클래스는 스스로 new 시킬 수 없다
			> 추상클래스는 몸체가 없어도 만들 수 있기 때문에 혹시라도 기능이 없는 함수가 존재할 수 있어서 new 불가능
		
		1. 다른 클래스에 상속해준 후 추상함수에 기능을 만들어주고(Override)
		   하위 클래스를 new 시켜서 사용한다
		   		> 실제로 이렇게 사용하는 경우는 거의 없다
		2. 멤버 함수 중, 속성이 static이면서 반환값이 자기자신인 함수를 호출한 후,
		   객체를 만들어서 사용
		   		예 ) Calendar 클래스
		   				Calendar cal = new Calendar();	> 절대 불가능
		   				Calendar cal = Calendar.getInstance();		> 인스턴스를 만듦 = 객체화

				참고 ) 추상클래스가 아님에도 new 불가능한 클래스
					   생성자 함수가 없는게 아니라 접근지정자를 private으로 해서 감춰둔 클래스라서 못하는것
									> 속성이 static이면서 반환값이 자기자신인 함수를 호출해서 사용
									> 해당 클래스에 이런 함수가 없는 경우, 관련 클래스에서 해당 클래스타입의 데이터를
									  반환해주는 함수가 있을 것이므로 그거 사용
									> 이것마저도 없으면 상속시켜서 해야함
									
		
인터페이스(Interface)
	: 클래스의 한 종류
	: 일반적인 클래스와는 형태와 의미가 다르다
		1. 최상위 클래스가 Object가 아님
			> 다른 클래스를 상속받아서 만들어진 클래스가 아님
			> 그래서 클래스가 아니라 인터페이스라고 부르는것
		2. 이 안에는 반드시 추상함수가 존재해야한다
			> 절대로 일반함수가 존재해서는 안된다 = 기능을 가진 함수가 존재해서는 안됨
			> 인터페이스 안의 추상함수에는 abstract 생략 가능(애초에 추상함수가 아니면 못오니까)
		 	> 인터페이스 안에서 함수를 정의할 때, 접근지정자와 속성을 지정하지 않으면 
		 	  자동으로 public abstract 로 만들어짐 (인터페이스를 상속받아서 안에 있는걸 써야하니까 퍼블릭)	
		 			예 ) public interface Sample { void abc();} = public interface Sample { public abstract void abc();}
		3. 인터페이스는 다른 클래스에 상속해줄때 다중 상속이 가능하다
			> 동시에 나열해서 상속받을 수 있다
		4. 변수를 가질 수 있다.
		   이때 변수는 자동으로 public static final 변수가 된다
		5. 인터페이스 소속 함수는 자동으로 public 함수가 된다
		
	인터페이스 만들기 
		형식 ) [접근지정자] interface 인터페이스이름 { 
					변수;	> public static final 변수
					함수;	> public abstract 함수
				}			
				
	인터페이스의 존재 이유
		: 가끔은 자바가상머신에 의해 자동 호출되어야하는 함수가 필요하다
		  따라서 호출하기 위해 함수의 존재는 필요하지만 가끔은 기능을 정하지 못하는 경우가 있다
		  그래서 기능은 개발자의 몫으로 남긴 것이다
		  
	자바에서 이벤트를 처리하는 순서
		1. 사용자가 버튼을 클릭하면 발생
		2. 이 이벤트는 운영체제가 인지하여 이벤트가 발새안 프로그램을 구분해서
		   그 프로그램을 담당하는 플랫폼(JVM)에게 통보한다
		3. JVM은 통보받은 이벤트를 분석하고 그 정보에 합당한 함수를 호출하여 이벤트를 처리한다 
				> 합당한 함수를 호출한다 = 함수가 존재한다
				> 단, 이벤트가 발생하면 무엇을 처리할지는 JVM이 결정하는 것이 아니다
					예 ) 내가 색변경을 원하는지 창닫기를 원하는지는 모름
	
	인터페이스 사용하기
		1. 인터페이스는 스스로 new 불가능
			> 추상클래스와 마찬가지로 인터페이스 소속함수는 모두 기능이 없는 추상함수이기때문
			> 따라서, 일반 클래스에게 상속함
				상속 방법 ) [접근지정자] class 클래스이름 implements 인터페이스이름 {
										추상함수 오버라이드
							}
							[접근지정자] class 클래스이름 implements 인터페이스1, 인터페이스2, ..., 인터페이스n {
										추상함수 오버라이드
							}
								> 다중상속의 경우, 상속받은 모든 인터페이스 내의 추상함수의 몸체를 만들어야한다
								
			> 일반 상속과 인터페이스 구현을 동시에 할 수 있다
				형식 ) public class 클래스이름 extends 상속해줄클래스이름 implememnts 인터페이스1, 인터페이스2 {
					   			추상함수 오버라이드(모든 함수 몸체 만들어야함)
					   }		>반드시 extends가 먼저 와야한다	
					   
					> 왜 extends가 아니라 implements 인가? 
					  일반 클래스는 기능을 상속받지만 인터페이스는 상속받아 구현하는 것이기 때문  
					  따라서 일반 클래스 상속은 "상속" / 인터페이스 상속은 "구현" 이라고 부름
			> 상속받은 클래스에서는 인터페이스 안의 모든 추상함수의 몸체를 만들어줘야한다 (필요한 기능을 개발자가 구현)
			  그리고 상속받은 클래스를 new 시켜서 사용
			  	>인터페이스 사용은 대부분 이 방법을 이용
				> 인터페이스 소속 함수와 변수의 접근지정자는 모두 public이라 구현할때도 public만 가능
	    2. 추상클래스처럼 속성이 static이면서 반환값이 자기자신인 함수를 사용한다
	    	> 인터페이스에는 추상함수만 올 수 있어서 인터페이스 자체가 아닌 관련 클래스에서 이러한 함수를 찾아써야함
	    	> 추상클래스에는 자체에 이런 함수가 있을 수 있다(여긴 일반함수 들어있어도 되니까)
		
		
			참고1 ) 인터페이스도 다른 인터페이스를 상속받아서 인터페이스 만들 수 있다
						형식 ) public interface 인터페이스이름 extends 상속해줄 인터페이스이름 { }
									> 이건 구현이 아니라 단순 상속이기 때문에 extends
			참고2 ) 원칙적으로 인터페이스 안에는 일반함수를 사용할 수 없다
					단, 예외적으로 일반함수가 올 수 있는 경우가 있는데 반드시 함수 속성에 
					default 라고 명시해야한다
					
					
					
내부클래스 (Inner class) : 클래스 내부에 만들어지는 클래스
	종류
		1. Top Level Inner Class	@See day07 - Test05 
			> 형식은 내부클래스이지만 독립적으로 활동하느 클래스
			> 형식 ) static class 클래스이름{}
				> 내부에 만들어지는 클래스에 static 속성이 부여되면 탑레벨 내부 클래스가 된다
			> "바깥클래스이름.내부클래스이름" 의 형식으로 접근해야한다
			
		2. 전역 Inner Class		@See day07 - Test06 
			> 일반 클래스를 내부 클래스로 만든 것
			> 가장 일반적인 내부클래스
			> 형식 ) class 클래스이름{}
			> 특징	
				1. 바깥 클래스의 모든 멤버를 자동으로 자신의 것처럼 사용할 수 있다
				2. 반드시 바깥 클래스가 new된 후에 안쪽 클래스를 생성할 수 있다
					> 클래스자체는 틀이라 바깥 클래스를 객체화 시킨 후에 안쪽에 만들 수 있다
					> 형식 ) 바깥클래스주소.new 내부클래스이름();
				3. 바깥클래스는 내부 클래스 멤버를 사용할 수 없다(지역변수와 같은 개념이라)
					>사용을 원하는 경우는 new 시킨 후 주소를 통해 접근해야한다
					주로 바깥 클래스와 연관된 기능을 가진 클래스를 만들고 싶을때 사용					
		3. 지역 Inner Class
			> 내부 클래스를 만드는 위치가 바깥 클래스의 함수 내부에서 만들어진다
				> 해당 함수의 블럭 밖 다른곳에서는 사용 불가
			 	> 예 ) void abc() { class localInner { 클래스내용} new localInner(); } }
			> 특징
				1. 전역 내부클래스와 유사하게 바깥 클래스 멤버 사용가능
				2. 이 클래스는 다른 곳에서 new 시켜 사용할 수 없다
				   오직 해당 함수 안에서만 new 시켜 사용할 수 있다
		4. 무명 Inner Class 
			> 프로그램을 제작하다보면 기능 수정을 위해 오버라이드가 필요한 경우가 있다
			  이때 원칙적으로는 별도의 클래스를 만들고 그 클래스를 new 시켜 사용해야하지만
			  변경내용이 간단한 경우는 무명 내부 클래스를 만들어 처리한다
			> 클래스를 new 시키는 순간 만들어지는 인스턴스를 바로 사용하면 된다
				> new 시킨 결과물만 있으면 되니까 이름도 붙일 필요가 없다
				>사용자가 클래스 이름을 만들지 않아도 됨
			> 형식 ) new 클래스이름 또는 인터페이스이름(){}
						> 보통 직접 new 시키지 못하는 클래스(추상클래스)를 '클래스이름 또는 인터페이스이름'에 넣는다



가변인자
	함수를 정의할 때 그 함수가 가지고있는 매개변수는 동일한 갯수, 형태, 순서를 이용해서 호출해야한다
	하지만 데이터의 개수가 정해지지 않은 경우가 있는데 이런 때에 사용할 수 있는 					  