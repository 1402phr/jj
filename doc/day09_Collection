#day09

Collection : 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합 (배열처럼 여러 데이터를 한번에 다룰 수 있도록 해주는 클래스)
			 배열을 사용해도 가능하지만 한번 데이터의 개수를 정하면 수정이 불가능하다는 단점이 있음(그래서 깊은복사해서 씀)
			 	> = 데이터 입출력에 제약이 있다
			 	> 또한 반그시 위치를 알아야 데이터 입출력이 가능하다
			 데이터의 양에 관계없이 항상 데이터를 입력받을 수 있다
			 이때 데이터를 입력받기 위한 공간 확보의 기본 규칙은 기존공간 * 2 이다
			 
	주요 함수 )
		1. 데이터를 입력하는 함수 
			 >add(Object e) : Object형태로 데이터를 자동 형변환 시키기 때문에 
			 				  나중에 다른 형태의 데이터로 사용하려면 강제 형변환이 필요하다
			 >add(int index, Object elememnt)
			 >addAll(Collection)
			 >add(int index, Collection c)
			 >addElement(Object obj)
			 > insertElementAt(Object obj, int index)
			 
		2. 데이터를 수정하는 함수
			 > set(int index, Object element) : 
			 > set(Object element, int index) : 
			 
		3. 데이터를 꺼내는 함수
			 > get(int index) : int index를 꺼내주세요
			 > elementAt(int index)
			 > firstElement() : 첫번째 데이터 꺼내주세요
			 > lastElement() : 마지막 데이터 꺼내주세요
			 > elements() : 모든 데이터 다 꺼내주세요
			 
	종류 )	
		1. list 계열, set 계열 : Collection을 상속받았기 때문에 상호 형변환 가능 
								 	> 이것을 다형성 처리가 가능하다고 부른다
								 상호 형변환은 가능하나 변환시킨 형태의 데이터에 get함수를 이용 못할 수 도 있음
								 	> 함수는 인스턴스를 다르는데 데이터의 인스턴스에 get을 사용 못하는 경우가 있기때문
				> list : 중복 데이터 입력 가능
						 데이터를 넣은 순서대로 고정됨 = 인덱스가 있음
						 처리 속도가 느리다
				> set : 중복 데이터 추가 불가능
							> 먼저 입력된 중복데이터 삭제후, 나중에 입력된 것으로 저장
					    입력 순서를 보장하지않음(나름의 규칙대로 정렬시킴) = 인덱스가 없음 = 데이터를 꺼내는 함수가 없음
					    처리속도가 빠르다
					    데이터를 꺼내려면 1. list로 형변환을 해줘야함
					    				  2. Iterator 사용
					    				  		>StringTokenizer처럼 버퍼에 올려서 꺼내는 것
		2. map : Collection을 상속받지 않음
					> list, set과 부모 클래스가 다르기 때문에 독립적으로 변환이 불가능하다 = 다형성 처리 불가능
			 	 데이터를 저장할때 그 데이터를 구분할 키값과 내용의 쌍을 만들어서 입력 = (key, value)
			 	 key값을 알아야 데이터를 꺼내올 수 있음
			 	 입력순서를 보장하지않는다
			 	 같은 키값이 입력되면 먼저 입력된 데이터 내용은 삭제하고 그 쌍에 나중에 저장된 내용을 저장
			 	 	> 즉, 데이터 내용은 같아도 되지지만 키값은 같으면 안된다
			 	 	
			 	 	
			 	 	
			 	 	
	list 계열
		종류 )	
			1. ArrayList  : Vector의 신버전, 배열보다 편하다	
						   		> 내부적으로 배열형태를 만들어 관리하기 때문에 Vector의 특징을 그대로 가짐
						   		> 스레드에서 동기화 처리를 자동으로 해주기 때문에 요즘 가장 많이 쓰음
						    list 계열의 주소를 출력하면 마치 데이터가 출력된것처럼 보이지만 
						    이것은 toString()을 오버라이드 해놓아서 내용만 출력될 뿐, 절대로 데이터를 사용하는 개념은 아니다  		
						   						   	
			2. Vector : 내부적으로 배열형태를 만들어 데이터를 보관하는 컬렉션의 한 종류
						데이터의 변화가 거의 없는 프로그램에서 많이 사용한다
							장점 > 입력속도와 검색속도가 빠르다
							단점 > 중간에 데이터를 입력 또는 삭제하는 속도가 느리다
						생성방법 ) 	
							1. Vector() : 배열의 크기를 10으로 설정한 형태로 벡터를 만듦
									 	  데이터가 크기를 초과하는 순간, 크기는 2배가 된다
							2. Vector(Collection c) : 다른 컬렉션의 데이터를 복사해서 데이터를 만듦
													  여기서 매개변수리스트인 Collection은 인터페이스(java.util - Collection)
													  Collection을 상속받은 list, set도 매개변수리스트에 넣을 수 있다(자동형변환)
													  인터페이스를 상속받은 Vector(Collection c)도 인터페이스이다
							3. Vector(int initialCapacity) : 사용자가 직접 계열의 크기를 정해서 만드는 벡터
							4. Vector(int initialCapacity, int capacityIncrement) : 3번 + 데이터의 양이 초과될 경우, 증가할 크기를
																					설정해서 벡터를 만든다
																					 
			3. LinkedList : 내부적으로 이중 연결 리스트 방식으로 데이터를 보관하는 방식의 컬렉션의 일종(물분자처럼..)
								장점 > 데이터를 중간에 끼워넣거나 삭제하는 작업의 속도가 빠르다
								단점 > 데이터를 누적시키는 작업의 속도는 느리다
								
참고 ) Iterator : 데이터를 꺼내기 위해서만 사용하는 클래스
		Enumeration의 신버전
			컬렉션은 많은 클래스의 집합이고 그 형태도 다르다
			그런데 이들은 서로 혼용될 수 있다
			다만, 데이터를 꺼내는 방식은 약간씩 다르다
			이때 데이터를 꺼내는 방식이 약간씩 다른건 다 기억하기 싫으니 나온게 이것
			
			따라서, list, set 계열 가리지 않고 Iterator로 변환만 시켜주면 같은 방식으로 데이터를 꺼낼 수 있다
				> = 꺼내는 소스를 통일해서 사용할 수 있다
			단, 순차적으로만 꺼낼 수 있고 한번 꺼낸 데이터는 자동 삭제된다(StringTokenizer와 유사)



Collections : 이름은 컬렉션이지만 실제 컬렉션은 아니고
			  컬렉션을 이용할 때 필요한 부가 기능을 제공하는 유틸 클래스
		주의 > list를 달라고 하면 list는 인터페이스이기 때문에 new 시켜서 객체를 만들 수 없으니
			   이때 list 계열을 입력하면 된다
			   Collection을 달라고하면 list/set 계열을 주면 된다
			   map을 달라고하면 map 계열을 주면 된다
		
		참고 > 일반적으로는 오름차순 정렬
			   만약 정렬 방식을 변경하고자 한다면, 
			   sort(List list, Comparator c)를 사용해야한다
			   
			   
Set : 입력 순서와 관계없이 자신의 정렬 기준을 가지고 데이터를 정렬해 보관
	  중복된 데이터는 저장 불가능하여 같은 데이터가 입력되면 이전에 입력되었던 것을 삭제하고 나중에 입력된 것을 저장한다
	  데이터를 꺼낼 수 있는 방법이 없다
	  	> 자체 정렬을 하기 때문에 개발자는 데이터 주소를 알 수 없고, 주소를 모르면 꺼내올 수 없음
	    > 그래서 Iterator를 사용하여 순서대로 꺼내 사용하도록 하고 있다 
	  
	종류 )
		1. HashSet : set 계열은 자신의 정렬 규칙을 가지고 데이터를 보관하는데, 
					 HashSet의 정렬 규칙은 HashCode이다
					 	 > 클래스를 출력하면 나오는 @어쩌구가 해시코드임
		
		2. TreeSet : 내부적으로 Tree sort라는 알고리즘을 가지고 데이터를 보관하는 기능을 가진 컬렉션의 일종
					 일반적으로 알려진 정렬 방식으로 정렬한다
					 	생성 방법 ) TreeSet(Comparator comparator) : 정렬방식을 변경해서 TreeSet을 만든다
					 												 comparable한 데이터만 가능
					 				TressSet(SortedSet<E> s) : 여기서 SortedSet은 인터페이스
					 										   TressSet을 이용해서 TressSet을 만든다
	   
					
	comparator : 비교 가능/ 불가능을 가리지 않고 사용 , 비교자
				 
	comparable은 비교 불가능한 경우도 정렬을 위해 비교 가능하도록 도와주는 녀석
	
	
	
map : 하나의 데이터를 다른 것과 구분할 키값과 한쌍으로 만들어서 기억하는 컬렉션의 일종
	  부모 클래스가 Collection이 아니다
	  사용할 경우에는 키값을 사용해서 데이터를 꺼낼 수 있도록 해두었다
	  많은 양의 데이터를 보관하는 용도 보다는 데이터를 손쉽게 구분하여 사용할 목적으로 사용한다
		
		종류 ) 	
			1. Hashtable : 구버전 
						   내부적으로 키값을 정렬할 때 해시테이블을 이용하고 보관한다
						   		주요함수 )
						   			1. put(Object key, Object value)  : 입력함수
						   			2. get(Object key) : 추출함수
						   		참고함수 )
						   			1. values() : 데이터만 꺼내서 사용할 수 있는 함수
						   			2. keys() : 키값들만 꺼내서 사용할 수 있는 함수
						   							> keys()로 꺼낸 데이터는 Enumeration으로 반환한다
						   							> 이누머레이션 : Iterator의 구버전
						   							> 데이터를 순차적으로 꺼낼 수 있는 클래스
			2. Hashmap : 신버전
						 	주요함수 )
						 		위와 동일
						 	참고함수 )
						 		1. keySet() : 키값만 꺼내는 함수, set으로 키값을 꺼낸다
						 			> entrySet() : map은 반드시 키값을 알아야 데이터를 꺼낼 수 있는데 
						 						   set은 데이터가 오직 한개씩 저장된다
						 						   따라서 map의 데이터를 set에 넣고 싶으면 
						 						   어떻게해서든지 키값과 데이터를 묶어야만 set에 입력된다
						 						   이 문제를 해결하기 위해 VO 클래스를 만들어서 제공해주고 있는데
						 						   그 클래스가 Map.Entry이다
						 						   		> 이 클래스 안에는 key와 value 변수를 은닉화 시켜놨고
						 						   		  이 변수를 사용할 수 있는 함수를 제공하고 있다
						 						   		  
			3. TreeMap : TreeSet과 마찬가지로 내부에서 정렬하며 데이터를 기억하는 맵
					     이때 정렬 기준은 키값이며, 키값이 정렬되지 않는 데이터라면 입력이 불가능하고
					     필요하다면 정렬방식을 정해서 사용해야한다(comparable)
					     
					     
참고 
	1. 컬렉션 안에는 컬렉션이 들어갈 수 있다
		> 컬렉션에 입력되는 데이터 타입은 Object이고 자바의 모든 데이터는 Object 타입으로 형변환이 가능하기 때문
	2. 컬렉션에 기억되는 데이터 타입이 별도 지정되지 않으면 Object 타입으로 자동 변환되어 기억된다
	   따라서, 꺼내서 연산을 할 경우에는 반드시 원래 타입으로 강제 형변환을 해서 사용해야한다 
						 			
			
	 
			 	 
오늘 4일 ~~ 사은품 지정 문의(완) / 루루 합배 탑승 완료
내일 5일 ~~
모레 6일 ~~ 오프닝클럽 마감
내일모레 7일 ~~ 
이젠 뭐라부르지 8일 ~~
9일 ~~
10일 ~~ 힝구 마감 
