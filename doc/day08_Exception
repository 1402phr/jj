#day08

예외처리 : @see day08 - Test01
		   프로그램적으로는 문제가 없으나(=문법상 문제는 없음)
		   데이터 또는 장비등의 문제로 프로그램 실행 도중 발생하는 에러를 
		   실행에러(Runtime error)라고 표현하며
		   자바에서는 이것을 예외(Exception)라고 한다
		   
		   이런 예외는 개발자가 예측해서 실제로 문제가 발생했을 시에 대처하는 방식으로
		   프로그램을 만들어야한다
		   예외가 발생했을 경우 대처하는 방식의 프로그램을 작성하는 것을 '예외처리'라고 한다
		   
	예외처리 문법)
		
		(1)try { 
				(2) 예외가 발생할 가능성이 있는 실행문
		} (3)catch(예외정보클래스 변수) {			//'예외에대한정보를담은클래스'상속받는 클래스의 오류까지 포함함
							(4) 예외가 발생했을 때 대처하는 부분
		} (5)finally {
							(6) 예외 발생 여부에 상관없이 마지막에 항상 실행되는 부분		
		}
		
		실행순서 )	
			1. 예외발생 : (1) > (2) > (4) > (5) > (6)
			2. 예외발생 안함 : (1) > (2) > (3) > (5) > (6)
				> (3)은 실행문에 예외가 발생한 경우에는 실행되지않는다
				> try 블럭({})의 범위에 따라서 
				
		예 ) 
			try {
					파일오픈 + 내용을 읽어서 화면에 출력 	
			}		
				> 파일오픈이 불가능하면 + 뒷부분의 코드는 읽지않음
				
	자바의 예외처리 원리 )
		예외 발생시 자바가상머시은 발생한 예외의 종류를 분석하여 
		예외에 대한 정보를 클래스(객체)로 만들고 catch 부분에 클래스 주소를 전달한다
		
		>catch의 의미 : 예외가 발생하면 에외의 정보를 받아 개발자가 원하는 처리를 해줘야한다
		
		>다중 catch : try 안에 예외발생요소가 여러가지 복합적인 예외발생요소를 가질 수 있다
					 이런 경우, 반드시 어떤 예외 때문인지를 구분해야한다면 다중 catch를 쓰면 된다
					 
				형식 ) 
					try {
					} catch(예외1) {
					} catch(예외2) {
					} 
					...
					catch(예외n) {
					} [finally {
					}]
			   		
			   		: catch에 적는 예외의 순서는 범위가 좁은 것부터 나열한다 
			   			> 범위가 넓은걸 위에 적으면 아래는 당연히 실행되지않기 때문에 오류가 발생
			   			
		> finally 블럭 : 예외 발생여부와 관계없이 반드시 실행되는 블럭
			>만약 finally가 존재하면 catch 블럭을 생략할 수 도 있다 
				> 문법상 오류는 없으나 이렇게 쓰느 경우가 잘 없음
				> 차라리 finally 생략하고 catch만 쓰는건 좀 있음
				
	
	예외정보 출력방법 )
		1. 예외정보클래스 변수를 출력
			> 예 ) System.out.println(예외클래스변수);
			> 예외의 원인만 알려줌
		2. 변수.printStackTrace()
			>예외의 정보 + 예외발생위치
			> 그 경로를 추적해서 출력해준다
			
			
	예외처리는 예외가 발생하면 개발자가 그것을 수정해서 정상적으로 작동하도록 하는 행위
	하지만, 정상작동하도록 만드는 작업은 매우 어려운 일이고 완벽해지는 경우가 많지않다
	그럼에도 예외처리를 하는 실제 이유는 예외의 정보를 미리 알아서 사용자에게 문제발생의 이유를 알려주고
	프로그램이 *정상종료*되도록 하는것이 목적이다 	
		

	
예외전이하기
	:함수는 프로그램의 가장 작은 단위로 한가지 작업을 하기 위해 만든것이다
	따라서 함수 안에서 작업하다가 예외가 발생하면 해당 함수는 더이상 실행할 필요가 없는 경우가 많다
	그래서 함수는 예외를 전이하도록 해놓은 경우가 많다
	
		형식 ) 반환값타입 함수이름(매개변수리스트) throws 예외클래스1, 예외클래스2,... {	}
		의미 ) 이 함수를 실행하는 도중 지정한 예외가 발생하면 실행해도 의미가 없으므로
			   이 함수를 사용하는 곳에서 반드시 예외처리하라
		참고 ) 예외가 전이된 함수는 반드시 사용하는 곳에서 예외처리를 해주어야한다
		예외 ) 함수가 예외를 전이하는 함수라도 예외처리를 하지않아도 되는 경우
				1. 전이하는 예외가 RuntimeException 하위의 예외인 경우에는 예외처리 해도그만, 안해도 그만
					> 주로 java.lang패키지 소속에 있는 함수들의 경우가 많음	= JVM이 자동 예외처리
					> 하지만 하는것이 추천된다..
					
					
					
강제예외던지기
	:자바가상머신이 예외로 인정하지않음에도(예외처리가 필요하지않음에도)
	 프로그램의 목적상 예외로 인정해야하는 경우가 있다
	 	예 ) 부서번호는 10, 20, 30, 40 중 하나를 입력하는데 11을 입력하는 경우 
	 		 자바가상머신은 예외인정하지않지만 강제로 예외처리해야함
	 		 
	   형식 ) throw new 예외클래스이름();
	   
	   
	   
사용자예외클래스 만들기
	: 예외클래스는 예외발생원인을 알려주는 역할을 담당한다
	  그런데 강제 예외던지기는 자바가 만들어놓은 예외가 아니기 때문에 예외의 원인을 파악하기 힘들다
	  이런경우, 예외의 원인을 파악하기 위해서 사용자가 예외정보를 만들어주는 클래스를 따로 만들어서 사용한다
	  
	  방법) 
	  	1. Exception 클래스를 상속받아서 클래스를 만든다
	  	2. toString()을 오버라이드하여 예외의 원인을 출력할 수 있도록 한다
	  		> print()안에 변수를 넣으면 toString()이 자동 호출된다
	  		> toString()은 Object를 상속받았고 문자열을 반환하는 함수이다
	  		  매개변수는 없어서 str.toString();과 같이 쓰인다
	  		>toString() 오버라이드 방법
	  			public string.toString() {
	  				"문자열" 
	  				 return;
	  			}
	  			
	  			
	  			
