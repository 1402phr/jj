#day06_접근지정자
접근지정자
	: 그 내용을 누구(어디)까지 사용할 수 있는지를 지정하는 예약어
	  즉, 우리가 클래스를 만든다고 해서 그 클래스(내용)을 모든사람에게 공개해야하는 것은 아님
	  그래서 클래스를 제작하는 사람이 사용범위를 지정할 수 있도록 한 것
	  	> new 시켜서 사용할 수 있는 범위는 어디까지?
	  	>어디까지 이 함수를 호출할 수 있도록 할까?
	 
	 종류 	
	 	1. public : 누구나, 모든 곳에서 사용 가능
	 	2. protected : 상속받은 하위 클래스 + 같은 패키지 소속에서만 사용 가능
	 	3. 생략 : 같은 패키지 안에서만
	 	4. private : 같은 클래스 안에서만
	 				 변수를 숨긴다고 부른다(은닉파)		> 객체지향언어의 특징
	 				 함수로는 가져올 수 있음(캡슐형) 	> 객체지향언어의 특징
	 	
	 참고 : 클래스에는 public / 생략만 가능하다
	 			예 ) public static main ....
	 			

은닉화 	: 접근지정자를 private로 지정
	프로그램에 있어서 가장 중요한 요소는 데이터
	 	>프로그램 자체가 데이터를 만들어내는 것(다른데서 가져와서 가공 / 자체적으로 만들어냄)
	즉, 변수가 프로그램의 핵심적인 요소가 된다는 것(데이터를 변수에다 기억시키기 때문)
	무결성 데이터(하자가 없는 데이터)를 유지할 수 있는가가 가장 중요한 개념이다
	은닉화란, 이처럼 중요한 변수를 사용자가 함부로 변경하지 못하도록 방지하는 기술을 이야기한다
		> 하자가 있는 데이터가 발생하지 않도록 하는 것
		
	방법 )
		1. 데이터가 기억될 변수를 private로 처리(타 클래스에서 변경/입력은 물론 열람도 차단)
		2. 대신 이 변수의 값을 변경하거나 읽을 수 있는 기능(함수)를 만들어준다
				>Getters & Setters
				
this
	교과서적인 의미로 현재 실행중인 오브젝트의 주소를 기억하는 약속된 변수
	
	이것은 자바 가상머신이 클래스를 처리하기 위해서 사용하는 변수
	따라서 개발자는 거의 이 변수를 사용하지않는다
	
	규칙
		1. 모든 멤버는 사용할 때 반드시 앞에 주소가 있어야한다
		   멤버는 클래스 란에 만들어진 변수나 함수를 이야기한다
		2. 만약 주소가 없으면 자바가상머신이 자동적으로 this를 앞에 붙여준다
		3. 멤버함수를 호출할 때는 무조건 주소값을 함수에게 알려주도록 약속했고 
		   함수는 this 변수를 준비한 후, 함수룰 호출할 때 알려준 주소를 기억하게 된다
		   
	참고 : 개발자가 this를 사용해야하는 유일한 경우
				> 지역변수와 멤버변수(전역변수)의 이름이 동일한 경우
				  이 경우, 따로 지정하지않으면 지역변수를 사용하게 되는데 이러면 멤버변수에 데이터가 기억되지 않는다
				  앞에 this를 붙여주면 멤버변수임을 명확히 하기 때문에 제대로 데이터ㅏ가 들어간다 


				  
클래스 만드는 형식
	[접근지정자] [속성] class 클래스이름{}
함수 만드는 방법	
	[접근지정자] [속성] 반환값타입 함수이름(매개변수리스트){}
변수 만드는 방법
	[접근지정자] [속성] 데이터타입 변수이름;


		 			 
속성
	static : static 영역에 생기는 함수나 변수들에게 붙여주는 속성(static 함수, static 변수) 
		특징 )
			1. 프로그램이 실행되기 위해서 자바가상머신이 로딩하는 순간 저절로 생기는 영역
				>사용자가 별도로 요구하지 않아도 자동생성
			2. 한번 만들어진 변수나 함수는 두번 생기지 않는다
		
		static 변수	
			형식 ) [접근지정자] static 데이터타입 변수이름;	
				
			특징 )
				1. 여러 오브젝트(객체)가 공동으로 사용하는 변수가 된다
						> 오브젝트 복수개를 만들어도 static 변수는 오직 하나만 static 영역에 생김
						> 한 객체에서 데이터를 바꾸면 그 데이터를 사용하는 다른 객체들도 바뀐 데이터를 사용해야함
				2. new 시키지 않아도 사용할 수 있는 변수
						> 이미 메모리에 올라가있으니까(static 영역)
				3. 일반 함수 안에서 사용 가능
			사용방법 ) 
				클래스이름.변수이름;
				
		static 함수
			특징 ) 
				1. static 영역에 만들어짐
				 	>따라서 객체가 만들어지지 않아도 사용가능
				2. this를 사용할 수 없는 함수
					> 여러 군데서 쓰이는데 대체 어디서 쓰이는 함수를 지칭하는지 알 수 없기 때문
				3. static 함수 안에서는 static 멤버(변수)만 사용할 수 있다				
			사용방법 )
				클래스이름.함수이름();
				
			
멤버변수 초기화
	멤버 변수는 heap 영역에 생기므로 자동초기화된다
	하지만 경우에 따라 변수에 기본적인 값을 지정할 필요가 있다
	
		방법 )
			1. 명시적 초기화 : 변수를 선언하면서 값을 입력(가장 먼저 실행됨 : 변수는 클래스블럭 바로 아래에 만드니까)
					> 예 )int no = 10;
			2. 초기화 블럭을 이용한 초기화 : 인스턴스 변수에 대해서만 가능 (두번째로 실행됨)
					> 형식 : {이 안에 데이터 변수를 입력}
					> 예 ) int no;
					  	  { no = 10; }	>초기화 블럭
					> 불가능 ) int no;
					  		   no = 10;		>> 불가능!!!!!! 일반함수라 클래스블럭 바로 밑에 못옴
			3. static 블럭을 이용한 초기화 : static 변수에 대해서만 가능(두번째로 실행됨)
					> 예 ) class Test {
								static int no;
									static {
									no = 10;		>>초기화 블럭
									}
							}		
										
			
			4. 생성자 함수를 이용한 초기화 : 가장 마지막에 실행됨
					> 예 ) 	class Test {
								int no;
								
								public Test(int no)	{
									this.no = no;
									}
							}
							
						
상속 : 이미 만들어진 클래스의 기능(변수/함수)을 그대로 물려받아서(복사) 새로운 클래스를 만드는 방법
	   **타입때문에 좀 헷갈리는 부분임.....
	   **붕어빵은 왜 붕어빵인가? > 밀가루와 앙금을 가지고 붕어빵틀에서 찍어내니까
	   							 > 앙금의 양과 종류에 따라 종류는 다르지만 모두 붕어빵
	   이 개념이 생긴 이유는 소프트웨어의 개발 속도를 빠르게 하기 위한 방법임
	   		> 같은 코드를 다시 쓰라면 시간도 걸리고 오타 위험도 있으니까
	   	객체지향언어는 부품(클래스)단위로 프로그램을 만든 후, 그 부품들을 조립해서 원하는 결과를 얻어내는 언어
	   	만들고자 하는 부품(클래스)과 유사한 부품(클래스)을 가지고와서 복사한 후, 없는 내용은 추가하고 바꿀내용은 수정해서 사용
	   		> 있는 것을 빼는건 불가능 
	   		
	   		형식 ) class 클래스이름 extends 상속받을클래스이름{
	   				함수를 수정 도는 추가 
	   				}
	   		참고 ) 자바는 단일 상속만 가능 : 여러군데서 동시에 상속받을 수 없다
	   				> 예 ) class Test extends String, Integer {} 	> 절대 불가
	   				
	   		용어정리 )
	   			상속해준 클래스 : Super class, 상위 클래스, 부모 클래스, 조상 클래스
	   			상속받은 클래스 : Sub class, 하위 클래스, 자식 클래스, 자손클래스
	   				예 ) Object - Number의 부모/조상클래스, Integer의 조상 클래스
	   					 Number
	   					 Integer
	   					 
	   		생성관계에 있는 경우 생성자의 역할
	   			결론적으로 하위 클래스가 생성되는 순간, 상위 클래스는 자동 생성
	   				>생성되는 순간 생성자 함수 호출
	   				> 따라서 하위 클래스 생성시 상위 클래스의 생성자 함수 실행
	   			상위 클래스의 생성자 함수는 자동 호출되는 개념
	   			이때 호출되는 생성자 함수는 무조건 기본 생성자만 이용하게됨
	   			
	   			참고 )
	   				super : 실행중인 객체의 상위 클래스를 기억하는 변수
	   						this가 실행중인 객체 자기 자신을 기억하는 예약된 변수이듯이 super도 예약된 변수이다
	   							>반드시 소속을 밝혀야할 필요가 있는 경우 사용한다
	   				super() : 상위 클래스의 기본 생성자가 아닌 다른 특정한 생성자 함수를 호출할 수 있는 유일한 방법
	   						  this()와 같이 생성자의 첫줄, 첫 문장으로만 사용 가능
	   						  	예 ) public class Test extends Example {
	   						  			public Test();{
	   						  			super(); 	< 항상 상위 클래스의 생성자가 호출되므로 생략가능
	   						  						< 이거 안써도 자동 호출됨
	   						  			super(데이터); 	<상위 클래스의 기본 생성자가 아닌 생성자를 호출하는 방법
	   						  			}
	   						  		 }
	   						  		 

오버라이딩(Overriding : 함수의 재정의) 
	: 원래 기능을 살짝 고쳐쓰겠다는 의미
	  상속관계에 있는 하위클래스에서 사용
	  	
	  	방법 ) 
	  		0. 상위클래스에 오버라이딩을 실행할 함수가 있어야한다
	  		1. 상위클래스가 가진 함수의 원형과 동일한 형태로 만들어야한다
	  			> 함수의 원형(Prototype) : 반환값 + 함수이름 + 매개변수리스트
	  		2. 접근지정자는 같거나 넓은 방향으로 수정할 수 있다
	  		3. 예외처리는 같거나 좁은 방향으로 수정할 수 있다
	  		
	  	이렇게 오버라이딩을 하게 되면 내부적으로 상위 클래스의 함수가 숨겨지고 재정의한 함수가 실행된다 
	  	하지만 super.함수이름()하면 바꾸기 전 원래 함수가 나온다! 사라지지않아 다행이네~~
	  				 
	  

다형성 : 굉장히 중요한 개념이라네~~ 
	하나의 변수를 이용해서 여러 형태의 클래스를 사용하도록 하는 기법
	
	데이터의 형변환(Casting)
		1. 강제 형변환 : 큰 타입의 변수를 작은 타입의 변수에 담을때
		2. 자동 형변환 : 작은 타입의 변수를 큰 타입의 변수에 담을 때
		3. 리터럴 형변환 : 데이터를 입력한 순간 리터럴 풀에 쌓이는데(정수는 int, 실수는 double)
						   기본형이 아닌 다른 형태로 쌓이도록 하는것
						   	예 ) 10L : long 타입으로 담겠다	  
						   	
	주소의 형변환(Casting) : 원칙적으로 주소는 형변환이 불가능하다
							 즉, 주소는 heap 형태에 따라 주소가 결정되므로(배열만들때 같은 타입의 데이터만 넣을 수 있는 그거)
							 heap 형태가 다르면 주소를 기억할 수 없게 되버림
							 	예 ) int[] a = new int[5];	> 가능
							 		 Test t = new Ex01; 	> 불가능
							 하지만 단 한가지 경우에 한해서 주소의 형변환이 가능하다
							 바로 상속관계에 있는 클래스끼리는 가능한데 이런 관계를 
							 is a 관계라고 한다	 
							 	참고 ) has a 관계 : 멤버로 가지고 있는지를 묻는 것
							 	
				종류 )
					1. 자동 형변환 : 하위 클래스의 주소가 상위 클래스의 변수에 기억되는 것
					2. 강제 형변환 : 상위 클래스의 주소가 하위 클래스의 변수에 기억되는 것
									 원칙적으로는 불가능하며 강제로 형변환 해줄 수는 있다
									 	예 ) class Grand {
									 			void abc(){
									 				System.out.println("여기는 Grand");
									 			}
									 		}
									 		class Parent extends Grand {
									 			void abc() {
									 				System.out.println("여기는 부모클래스");
									 			}
									 			void abc() {
									 				System.out.println("한글사랑");
									 			}
									 		}	
									 		
									 		class Child extends Parent {
									 			void abc() {
									 				System.out.println("여기는 자식 클래스");
									 			}
									 		}
									 		 
									 		 Child c = new Child();		> 가능
									 		 Parent p = c;
									 		 
									 		 Parent p1 = new Parent();
									 		 Child c1 = p1;		> 불가능
									 		 Child c1 = (Child) p1; 	> 강제 형변환
									 				  		 
				다형성이란?
					주소의 형변환 이론을 기반으로 하여 
					상위 클래스의 주소를 이용해서 하위 클래스를 이용할 수 있으며
					상위 클래스의 주소를 이용하면 여러 하위 클래스를 다룰 수 있다